<h2> Introduction </h2>

<p>This article will focus on these questions:
<ol>
 <li>What is a pivot table?</li>  
 <li>Why would I ever want or need a pivot table?</li>
 <li>How do I create a pivot table?</li>
</ol>
To answer these questions, we'll create and use pivot tables with MySQL.
</p>



<h2>Background</h2>

<p><b>1. What is a pivot table?</b>  It's a summary of a table used for reporting, analysis, and quick summarization purposes.  
The name comes from the fact that the columns in the pivot table come from row values in the base table; these values are <b>pivoted</b> into columns.

Note in the following examples that row values became column headers in the pivot table -- thus the name.

<b>Note: define terminology with a small example here.  y-values, x-values, columns of interest, number of row & columns in pivot table, etc.</b>
</p>

<p><b>2. Why would I want a pivot table?</b> 
   Pivot tables provide summaries of data that are much easier to grok than the full table.  
   They typically focus on two columns, providing aggregate data which can help indicate the relationships between them.</p>

<p><b>3. How do I create a pivot table?</b> There is a straight-forward procedure for creating pivot tables: 
   (indicate no. of rows, columns after each step)
<ol>
 <li>select the two columns of interest.  
     Call them x and y:  the y-values become values in the first column, while the x-values become column headers.  
    The pivot table ends up with 1 y column, plus 1 column for each x-value</li>
 <li>create a view/query that adds extra columns to each row of the base table, indicating the type of the row</li>
 <li>aggregate the extended table using appropriate aggregate functions, grouping by the y-value column</li>
</ol>

<p><b>2. and 3. </b> will be covered in more detail in the remainder of this article.</p>



<h2>Example 1: pivoting investment data</h2>

<p>  
In this example, we'll look at data showing the shares purchesed during a number of investments made over three years 
(note: these are hypothetical companies -- if the names bear any resemblance to real companies' names, it is purely coincidental :).
We'll start with the table schema, some sample data, and the desired pivot tables:

<pre>
create table investment (
  id       int primary key auto_increment, 
  year     int, 
  person   varchar(50), 
  stock    varchar(50), 
  shares   int
);

mysql> select * from investment;
+----+------+---------+--------+--------+
| id | year | person  | stock  | shares |
+----+------+---------+--------+--------+
|  1 | 2009 | Matt    | Google |     27 |
|  2 | 2009 | Jeffrey | Google |     13 |
|  3 | 2010 | Timothy | Yahoo  |     31 |
|  4 | 2009 | Matt    | Yahoo  |      4 |
|  5 | 2011 | Timothy | IBM    |    100 |
|  6 | 2011 | Timothy | Google |     34 |
|  7 | 2010 | Jeffrey | Yahoo  |     68 |
|  8 | 2010 | Jeffrey | Yahoo  |     18 |
|  9 | 2011 | Matt    | IBM    |     49 |
| 10 | 2011 | Matt    | Google |     22 |
| 11 | 2011 | Timothy | Yahoo  |     51 |
| 12 | 2009 | Jeffrey | Yahoo  |     63 |
+----+------+---------+--------+--------+
</pre>

And here are the desired pivot tables.  
In the first, we're looking at the number of shares of each company bought by each investor, 
while the second, looks at the number of times each investor has bought stock in each company:

<pre>
mysql> select * from pivot_company_shares;
+---------+--------+------+-------+
| person  | Google | IBM  | Yahoo |
+---------+--------+------+-------+
| Jeffrey |     13 |    0 |   149 |
| Matt    |     49 |   49 |     4 |
| Timothy |     34 |  100 |    82 |
+---------+--------+------+-------+

mysql> select * from pivot_company_transactions;
+---------+--------+-----+-------+
| person  | Google | IBM | Yahoo |
+---------+--------+-----+-------+
| Jeffrey |      1 |   0 |     3 |
| Matt    |      2 |   1 |     1 |
| Timothy |      1 |   1 |     2 |
+---------+--------+-----+-------+
</pre>

<h3>Step 1: choose columns of interest</h3>
<div>We'll look at `person` and `stock` in this example.  `person` will provide the y-values, and `stock` the x-values.</div>

<h3>Step 2: extend</h3>
<pre>
create view investment_extended as (
  select
    investment.*, 
    case when stock = "Google"  then shares end as Google,
    case when stock = "IBM"     then shares end as IBM,
    case when stock = "Yahoo"   then shares end as Yahoo 
  from investment
);
</pre>

<h3>Step 3: group by y-values and apply aggregate function</h3>
<div>Here are two interesting aggregations of the extended data:</div>
<pre>
create view pivot_company_shares as (
  select 
    person, 
    sum(Google)            as Google, 
    coalesce(sum(IBM), 0)  as IBM, 
    sum(Yahoo)             as Yahoo 
  from investment_extended 
  group by person
);

create view pivot_company_transactions as (
  select 
    person, 
    count(Google)  as Google, 
    count(IBM)     as IBM, 
    count(Yahoo)   as Yahoo 
  from investment_extended 
  group by person
);
</pre>

<div>Note that in `pivot_company_shares`, we use `coalesce` to check the IBM column for null, returning 0 if it is and the column value otherwise.
This is because one of the investors didn't buy any IBM, and using `sum` on a bunch of null values returns null!
We could have just left it as null, but the 0 looks a lot nicer.</div>
</p>




<h2>Example 2: turning multi-row objects into single rows</h2>
<p>
Explanation of context, point, usefulness of example:
<pre>
create table point (
  id           int, 
  dimno        int, 
  coordinate   int, 
  primary key (id, dimno)
);

insert into point values
  (1, 1, 4),
  (1,2, 7),
  (1,3,2),
  (2,1,-3),
  (2,2,14),
  (2,3,14),
  (3,1,10),
  (3,2,5),
  (3,3,3);
</pre>
<b>make sure to paste results from intermediate tables to show progress!!!!! and end results!</b>

<h3>Step 1: choose columns of interest</h3>
<div>The y-values will be point-ids, and the dimension numbers will be the x-values.  That way, each point will be by itself on a single row.</div>

<h3>Step 2: extend</h3>
<pre>
create view point_extended as (
  select 
    case when dimno = 1 then coordinate end as x, 
    case when dimno = 2 then coordinate end as y,
    case when dimno = 3 then coordinate end as z, 
    point.* from point
);
</pre>

<h3>Step 3: group and aggregate</h3>
<pre>
create view point3d as (
  select 
    id, 
    max(x) as x, 
    max(y) as y, 
    max(z) as z 
  from point_extended 
  group by id
);
</pre>
</p>





<h2>Review of the technique</h2>
<ul>
 <li>what did we do</li>
 <li>how does the column extension work?</li>
 <li>how does the `group-by` magically get it right?</li>
 <li>how did it work??? lolz</li>
 <li>how do I apply this to my own data?</li>
 <li>usage of case-expression: nulls?  can another "neutral" value (such as 0) be used instead?</li>
</ul>





<h2>Conclusion and limitations</h2>

<p>Pivot tables are quite useful and relatively straightforward.  
   However, one downside to the approach I've outlined is that you have to know how many columns the pivot table will have <b>in advance</b>.
   The frustrations this causes can range from mildly annoying (adds extra typing) to severely limiting, if there are hundreds of values.
</p>

<p>The inspiration for this post came from reading the SQL Cookbook by Anthony Molinaro, chapter 12.
   I highly recommend this book to anyone interested in improving their SQL chops, from beginner to advanced.
</p>

